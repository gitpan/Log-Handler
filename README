NAME
    Log::Handler - A simple handler to log messages to log files.

SYNOPSIS
        use Log::Handler;

        my $log = Log::Handler->new( filename => $logfile, mode => 'append' );

        $log->alert("foo bar");

DESCRIPTION
    This module is just a simple log file handler. It's possible to define a
    log level for your programs and control the amount of informations that
    be logged to the log file. In addition it's possible to say how you wish
    to open the log file - transient or permanent - and LOCK and UNLOCK the
    log file by each log operation and if you wish you can assign the
    handler to check the inode of the log file (not on windows). This could
    be very useful if a rotate mechanism moves and zip the log file.

METHODS
  new()
    Call "new()" to create a new log handler object.

    The "new()" method expected the options for the log file. The only one
    mandatory option is "filename". All other options will be set to a
    default value.

  set_prefix()
    Call "set_prefix()" to modifier the option prefix after you called
    "new()".

        my $log = Log::Handler->new(
           filename => 'file.log',
           mode => 'append',
           prefix => "myhost:$$ [<--LEVEL-->] "
        );

        $log->set_prefix("[<--LEVEL-->] myhost:$$ ");

  get_prefix()
    Call "get_prefix()" to get the current prefix if you just want to
    modifier the current prefix and re-set the old.

        # safe the old prefix
        my $old_prefix = $log->get_prefix();

        # set a new one for a code part in your script
        $log->set_prefix("my new prefix");

        # now set the your old prefix again
        $log->set_prefix($old_prefix);

    Or you want to add something to the current prefix:

        $log->set_prefix($log->get_prefix."add something");

  Log levels
    There are eigth log level and twelve methods to handle this levels:

    emergency(), emerg()
    alert()
    critical(), crit()
    error(), err()
    warning()
    notice(), note()
    info()
    debug()

    "debug()" is the highest and "emergency()" or "emerg()" is the lowest
    log level. You can define the log level with the options "maxlevel()"
    and "minlevel()".

    The methods "note()", "err()", "crit()" and "emerg()" are just
    shortcuts.

    Example:

    If you set the option "maxlevel" to "warning" and "minlevel" to
    "emergency" then the levels emergency, alert, critical, error and
    warning will be logged.

    The call of all methods is very simple:

        $log->info("Hello World! How are you?");

    Or maybe:

        $log->info("Hello World!", "How are you?");

    Both calls would log (provided that the log level INFO would log)

        Feb 01 12:56:31 [INFO] Hello World! How are you?

  would_log_* methods
    would_log_emergency(), would_log_emerg()
    would_log_alert()
    would_log_critical(), would_log_crit()
    would_log_error(), would_log_err()
    would_log_warning()
    would_log_notice(), would_log_note()
    would_log_info()
    would_log_debug()

    This twelve methods could be very useful if you want to kwow if the
    current log level would log the message to the log file. All methods
    returns TRUE if the handler would log the message and FALSE if not.
    Example:

    You want to dump a big hash with Data::Dumper to the log file, but you
    don't want to pass the dump in any case, because it would costs a lot of
    resources.

        $log->debug(Dumper($hash));

    This example would dump the $hash in any case and handoff it to the log
    handler, but this isn't that what we really want!

        $log->debug(Dumper($hash))
           if $log->would_log_debug();

    Now we dump the $hash only if the current log level would really log it.

    The methods "would_log_note()", "would_log_err()", "would_log_crit()"
    and "would_log_emerg()" are just shortcuts.

    All methods that would NOT log the message returns TRUE.

  errstr()
    Call "errstr()" if you want to get the last error string. This is useful
    with the option "die_on_errors". If you set this option to 0 the handler
    wouldn't croak if simple write operations failed. Set "die_on_errors" to
    control it yourself. "errstr()" is only useful with "new()", "CLOSE()"
    and the log level methods.

        $log->info("log information") or die $log->errstr;

    Or

        $error_string = $log->errstr
           unless $log->info("log some informations");

    The error string contains $! in parantheses at the end of the error
    string.

    The exception is that the handler croaks in any case if the call of
    "new()" failed because on missing params or on wrong settings!

        my $log = Log::Handler->new(filename => 'file.log', mode => 'foo bar');

    This would croaks, because option "mode" except "append" or "trunc" or
    "excl".

    If you set the option "fileopen" to 1 - the default - to open the log
    file permanent and the call of "new" failed then you can absorb the
    error.

        my $log = Log::Handler->new(filename => 'file.log')
           or warn Log::Handler->errstr;

  CLOSE()
    Call "CLOSE()" if you want to close the log file.

    This option is only useful if you set option "fileopen" to 1. If you
    don't call "CLOSE()" the log file will be closed automatically before
    exit().

    Note that if you close the log file it's necessary to call "new()" to
    reopen it.

OPTIONS
  filename
    This is the only one mandatory option and the script croak if it not
    set. You have to set a filename, a GLOBREF or you can set a string as an
    alias for STDOUT and STDERR.

    Set a file name:

        $log = Log::Handler->new( filename => 'file.log'  );

    Set a file handle

        open my $fh, '>', 'file.log' or die $!;
        $log = Log::Handler->new( filename => $fh );

    Set a GLOBREF

        open FH, '>', 'file.log' or die $!;
        $log = Log::Handler->new( filename => \*FH );

    Set STDOUT or STDERR

        $log = Log::Handler->new( filename => \*STDOUT );
        $log = Log::Handler->new( filename => \*STDERR );

    If the option "filename" is set in a config file and you want to debug
    to your screen then you can set *STDOUT or *STDERR as a string.

        my $out = '*STDOUT';
        $log = Log::Handler->new( filename => $out );
        $log = Log::Handler->new( filename => '*STDOUT' );
        $log = Log::Handler->new( filename => '*STDERR' );

    That is not possible:

        $log = Log::Handler->new( filename => '*FH' );

    Note that if you set a GLOBREF to "filename" some options will be forced
    (overwritten) and you have to control the handles yourself. The forced
    options are

        fileopen => 1
        filelock => 0
        reopen   => 0

  filelock
    It's maybe desirable to lock the log file by each write operation. You
    can set the option "filelock" to activate or deactivate the locking.

        0 - no file lock
        1 - exclusive lock (LOCK_EX) and unlock (LOCK_UN) by each log message (default)

  fileopen
    Open a log file transient or permanent.

        0 - open and close the logfile by each write operation (default)
        1 - open the logfile if C<new()> called and try to reopen the
            file if reopen is set to 1 and the inode of the file has changed

  reopen
    This option works only if option "fileopen" is set to 1.

        0 - deactivate
        1 - try to reopen logfile if the inode changed (default)

  fileopen and reopen
    Please note that it's better to set "reopen" and "fileopen" to 0 on
    Windows systems because Windows unfortunately haven't the faintest idea
    of inodes.

    To write your code independent you should control that:

        my $os_is_win = $^O =~ /win/i ? 0 : 1;

        my $log = Log::Handler->new(
           filename => 'file.log',
           mode => 'append',
           fileopen => $os_is_win
        );

    If you set "fileopen" to 0 then it implies that "reopen" has no
    importance.

  mode
    There are three possible modes to open a log file.

        append - O_WRONLY | O_APPEND | O_CREAT
        excl   - O_WRONLY | O_EXCL   | O_CREAT (default)
        trunc  - O_WRONLY | O_TRUNC  | O_CREAT

    "append" would open the log file in any case and appends the messages at
    the end of the log file.

    "excl" would fail by open the log file if the log file already exists.
    This is the default option because some security reasons.

    "trunc" would truncate the complete log file if it exist. Please take
    care to use this option!

    Take a look to the documentation of "sysopen()" to get more informations
    and take care to use "append" or "trunc"!

  autoflush
        0 - autoflush off
        1 - autoflush on (default)

  permissions
    "permissions" sets the permission of the file if it creates and must be
    set as a octal value. These permission values need to be in octal and
    are modified by your process's current "umask".

    This means that you have to use the unix style permissions such as
    "chmod". 0640 is the default permission for this option. That means that
    the owner got read and write permissions and users in the same group got
    only read permissions. All other users got no access.

    Take a look to the documentation of "sysopen()" to get more
    informations.

  timeformat
    You can set "timeformat" with a date and time format that will be
    coverted by POSIX::strftime(). The default format is "%b %d %H:%M:%S"
    and looks like

        Feb 01 12:56:31

    As example the format "%Y/%m/%d %H:%M:%S" would looks like

        2007/02/01 12:56:31

  newline
    This helpful option appends a newline to the log message if not exist.

        0 - deactivated (default)
        1 - appends a newline to the log message if not exist

  prefix
    Set "prefix" to define your own prefix for each message. The default
    value is "[<--LEVEL-->] ".

    "<--LEVEL-->" is replaced with the current message level. Default
    example:

        $log->alert("message ...");

    would log

        Feb 01 12:56:31 [ALERT] message ...

    If you set "prefix" to

        prefix => 'foo <--LEVEL--> bar: '

        $log->info("foobar");

    then it would log

        Feb 01 12:56:31 foo INFO bar: foobar

    Take a look to the EXAMPLES to see more.

  maxlevel and minlevel
    With the options "maxlevel" and "minlevel" you can set the log levels
    you wish to log to your log file. The log levels are:

        7 - debug
        6 - info
        5 - notice, note
        4 - warning
        3 - error, err
        2 - critical, crit
        1 - alert
        0 - emergency, emerg

    The levels "note", "err", "crit" and "emerg" are just shortcuts.

    It's possible to set the log level as a string or as number. The default
    "maxlevel" is 4 and the default "minlevel" is 0.

    Example: If "maxlevel" is set to 4 and "minlevel" to 0 then only
    emergency (emerg), alert, critical (crit) and error (err) messages will
    be logged to the log file.

    You can set both to 8 or "nothing" if you don't want to log any message.

  die_on_errors
    Set "die_on_errors" to 0 if you don't want that the handler croaks if
    normal operations failed.

        0 - will not die on errors
        1 - will die (e.g. croak) on errors

    The exception is that the handler croaks in any case if the call of
    "new()" failed because on missing params or wrong settings.

  debugger
    You can activate a simple debugger to log "caller()" informations by
    each log operation. There are two debug modes: block(1) and line(2)
    mode. The debugger is logging all defined values except "hints" and
    "bitmask".

    The block mode looks like this:

        use strict;
        use warnings;
        use Log::Handler;

        my $log = Log::Handler->new(
           filename => \*STDOUT,
           maxlevel => 'debug',
           debugger => 1
        );

        sub test1 { $log->debug() }
        sub test2 { &test1; }

        &test2;

    Output:

       Apr 26 12:52:17 [DEBUG] 
          CALL(4):
             package     main
             filename    ./trace.pl
             line        15
             subroutine  main::test2
             hasargs     0
          CALL(3):
             package     main
             filename    ./trace.pl
             line        13
             subroutine  main::test1
             hasargs     0
          CALL(2):
             package     main
             filename    ./trace.pl
             line        12
             subroutine  Log::Handler::__ANON__
             hasargs     1
          CALL(1):
             package     Log::Handler
             filename    /usr/local/share/perl/5.8.8/Log/Handler.pm
             line        681
             subroutine  Log::Handler::_print
             hasargs     1
          CALL(0):
             package     Log::Handler
             filename    /usr/local/share/perl/5.8.8/Log/Handler.pm
             line        990
             subroutine  Devel::Backtrace::new
             hasargs     1
             wantarray   0

    The same code example but the debugger in line mode would looks like
    this:

           debugger => 2

    Output:

        Apr 26 12:54:11 [DEBUG] 
           CALL(4): package(main) filename(./trace.pl) line(15) subroutine(main::test2) hasargs(0)
           CALL(3): package(main) filename(./trace.pl) line(13) subroutine(main::test1) hasargs(0)
           CALL(2): package(main) filename(./trace.pl) line(12) subroutine(Log::Handler::__ANON__) hasargs(1)
           CALL(1): package(Log::Handler) filename(/usr/local/share/perl/5.8.8/Log/Handler.pm) line(713) subroutine(Log::Handler::_print) hasargs(1)
           CALL(0): package(Log::Handler) filename(/usr/local/share/perl/5.8.8/Log/Handler.pm) line(1022) subroutine(Devel::Backtrace::new) hasargs(1) wantarray(0)

  debugger_skip
    This option let skip the debugger the count of "debugger_skip".

        debugger_skip => 2

        Apr 26 12:55:07 [DEBUG] 
           CALL(2): package(main) filename(./trace.pl) line(16) subroutine(main::test2) hasargs(0)
           CALL(1): package(main) filename(./trace.pl) line(14) subroutine(main::test1) hasargs(0)
           CALL(0): package(main) filename(./trace.pl) line(13) subroutine(Log::Handler::__ANON__) hasargs(1)

EXAMPLES
  Simple example to log all level:
        use Log::Handler;

        my $log = Log::Handler->new(
           filename => 'file1.log',
           mode     => 'append',
           newline  => 1,
           maxlevel => 7,
           minlevel => 0
        );

        $log->debug("this is a debug message");
        $log->info("this is a info message");
        $log->notice("this is a notice");
        $log->note("this is a notice as well");
        $log->warning("this is a warning");
        $log->error("this is a error message");
        $log->err("this is a error message as well");
        $log->critical("this is a critical message");
        $log->crit("this is a critical message as well");
        $log->alert("this is a alert message");
        $log->emergency("this is a emergency message");
        $log->emerg("this is a emergency message as well");

    Would log this:

        Feb 01 12:56:31 [DEBUG] this is a debug message
        Feb 01 12:56:31 [INFO] this is a info message
        Feb 01 12:56:31 [NOTICE] this is a notice
        Feb 01 12:56:31 [NOTE] this is a notice as well
        Feb 01 12:56:31 [WARNING] this is a warning
        Feb 01 12:56:31 [ERROR] this is a error message
        Feb 01 12:56:31 [ERR] this is a error message as well
        Feb 01 12:56:31 [CRITICAL] this is a critical message
        Feb 01 12:56:31 [CRIT] this is a critial message as well
        Feb 01 12:56:31 [ALERT] this is a alert message
        Feb 01 12:56:31 [EMERGENCY] this is a emergency message
        Feb 01 12:56:31 [EMERG] this is a emergency message as well

  Just a notice:
        use Log::Handler;

        my $log = Log::Handler->new(
           filename   => '/var/run/pid-file1',
           mode       => 'trunc',
           maxlevel   => 5,
           minlevel   => 5,
           prefix     => '',
           timeformat => ''
        );

        $log->note("$$");

    Would truncate /var/run/pid-file1 and write just the pid to the logfile.

  Selfmade prefix:
        use Log::Handler;
        use Sys::Hostname;

        my $hostname =  hostname;
        my $pid      =  $$;
        my $progname =  $0;
           $progname =~ s@.*[/\\]@@;

        my $log = Log::Handler->new(
           filename => "${progname}.log",
           mode     => 'append',
           maxlevel => 6,
           newline  => 1,
           prefix   => "${hostname}[$pid] [<--LEVEL-->] $progname: "
        );

        $log->info("Hello World!");
        $log->warning("There is something wrong!");

    Would log:

        Feb 01 12:56:31 hostname[8923] [INFO] progname: Hello world
        Feb 01 12:56:31 hostname[8923] [WARNING] progname: There is something wrong!

  would_log_* example:
        use Log::Handler;
        use Data::Dumper;

        my $log = Log::Handler->new(
           filename   => 'file1.log',
           mode       => 'trunc',
           maxlevel   => 4,
           prefix     => '',
           timeformat => ''
        );

        my %hash = (
            foo => 1,
            bar => 2
        );

        $log->debug("\n".Dumper(\%hash))
            if $log->would_log_debug();

    Would NOT dump %hash to the $log object!

  die_on_errors example:
        use Log::Handler;
        use Data::Dumper;

        my $log = Log::Handler->new(
           filename      => 'file1.log',
           mode          => 'append',
           die_on_errors => 0
        ) or die Log::Handler->errstr();

        if ($log->would_log_debug()) {
           $log->debug("\n".Dumper(\%hash))
              or die $log->errstr();
        }

DEPENDENCIES
        Fcntl             -  for flock(), O_APPEND, O_WRONLY, O_EXCL and O_CREATE
        IO::Handle        -  to set autoflush on the log file handle
        File::stat        -  to get the inode from the log file
        POSIX             -  to generate the time stamp with strftime()
        Params::Validate  -  to validate all options
        Devel::Backtrace  -  to backtrace caller()
        Carp              -  to croak() on errors if die_on_errors is active

EXPORTS
    No exports.

REPORT BUGS
    Please report all bugs to <jschulz.cpan(at)bloonix.de>.

AUTHOR
    Jonny Schulz <jschulz.cpan(at)bloonix.de>.

COPYRIGHT
    Copyright (C) 2007 by Jonny Schulz. All rights reserved.

    This program is free software; you can redistribute it and/or modify it
    under the same terms as Perl itself.

DISCLAIMER OF WARRANTY
    BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
    FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
    OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
    PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
    EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
    ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
    YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
    NECESSARY SERVICING, REPAIR, OR CORRECTION.

    IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
    WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
    REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE
    TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR
    CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
    SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
    RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
    FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
    SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
    DAMAGES.

